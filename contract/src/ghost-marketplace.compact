// GhostSignal — Ghost Signal Marketplace Compact Contract
//
// This contract implements a ZK commit-reveal marketplace where AI trading agents
// publish cryptographic commitments to buy/sell signals, then reveal them later.
// Agent strategies remain private (never on-chain), while signal accuracy is
// publicly verifiable via on-chain ledger state.
//
// Architecture:
//   - Agents hash their signal data off-chain: secret = H(signal || salt)
//   - commit_signal stores persistentHash(secret) on the public ledger
//   - reveal_signal / verify_signal re-hash the secret and assert it matches
//   - The ZK proof guarantees the agent cannot change their signal after commit

pragma language_version >= 0.20;

import CompactStandardLibrary;

// ============================================================================
// PUBLIC LEDGER STATE
// ============================================================================
// All ledger fields are visible on-chain via the indexer.

// The cryptographic commitment for the current signal lifecycle.
// commitment = persistentHash(secret), where secret = H(signal_data || salt).
// This is the on-chain "fingerprint" — anyone can see the hash, but the
// preimage (the actual trading signal) remains private until reveal.
export ledger signal_commitment: Bytes<32>;

// Total number of signal commitments submitted across all agents
export ledger total_commitments: Counter;

// Total number of signals that have been revealed (completed commit-reveal)
export ledger total_reveals: Counter;

// Total number of signals verified as correct after market outcome
export ledger total_verified: Counter;

// Running count of active agents who have registered
export ledger active_agents: Counter;

// Total stake locked across all active commitments (in tNight units)
export ledger total_stake_locked: Counter;

// ============================================================================
// CIRCUITS (TRANSITION FUNCTIONS)
// ============================================================================
// Each circuit modifies public ledger state via zero-knowledge proofs.
// The secret parameter is a witness — it is used inside the proof but
// never disclosed on-chain.

// commit_signal: An agent commits a signal by providing a secret.
// The ZK circuit computes persistentHash(secret) and stores it on-chain.
// The signal data is encoded in the secret (computed off-chain as
// H(signal_json || random_salt)); only the hash appears on the ledger.
//
// On-chain effect:
//   signal_commitment = persistentHash(secret)
//   total_commitments += 1
//   total_stake_locked += 1
export circuit commit_signal(secret: Bytes<32>): [] {
  signal_commitment = disclose(persistentHash<Bytes<32>>(secret));
  total_commitments.increment(1);
  total_stake_locked.increment(1);
}

// reveal_signal: An agent reveals their signal by providing the same secret.
// The ZK circuit recomputes persistentHash(secret) and asserts it matches
// the stored commitment. If the preimage doesn't match, the transaction
// is rejected by the network — the agent cannot fake a reveal.
//
// On-chain effect:
//   assert(signal_commitment == persistentHash(secret))
//   total_reveals += 1
export circuit reveal_signal(secret: Bytes<32>): [] {
  assert(signal_commitment == persistentHash<Bytes<32>>(secret),
         "Reveal rejected: preimage does not match on-chain commitment");
  total_reveals.increment(1);
}

// verify_signal: After market outcome is known, verify signal integrity.
// Re-checks the commitment match and increments the verified counter.
// This provides an auditable on-chain record of verified predictions.
//
// On-chain effect:
//   assert(signal_commitment == persistentHash(secret))
//   total_verified += 1
export circuit verify_signal(secret: Bytes<32>): [] {
  assert(signal_commitment == persistentHash<Bytes<32>>(secret),
         "Verification failed: signal proof does not match commitment");
  total_verified.increment(1);
}

// register_agent: A new agent registers on the marketplace.
//
// On-chain effect:
//   active_agents += 1
export circuit register_agent(): [] {
  active_agents.increment(1);
}
