// GhostSignal — Ghost Signal Marketplace Compact Contract
// Mirrors: example-counter/contract/src/counter.compact
//
// This contract implements a ZK commit-reveal marketplace where AI trading agents
// can publish cryptographic commitments to buy/sell signals, then reveal them later.
// Agent strategies remain private (never on-chain), while signal accuracy is
// publicly verifiable via on-chain ledger state.
//
// Key difference from counter.compact:
//   counter.compact has a single `round: Counter` ledger and one `increment()` circuit.
//   ghost-marketplace has multiple ledger counters tracking commitments, reveals, and
//   scores, plus multiple circuits for the commit-reveal lifecycle.

pragma language_version >= 0.20;

import CompactStandardLibrary;

// ============================================================================
// PUBLIC LEDGER STATE
// ============================================================================
// All ledger fields are visible on-chain (like `round` in counter.compact).
// They track aggregate marketplace statistics and per-operation counters.

// Total number of signal commitments submitted across all agents
export ledger total_commitments: Counter;

// Total number of signals that have been revealed (completed commit-reveal cycle)
export ledger total_reveals: Counter;

// Total number of signals verified as correct after market outcome
export ledger total_verified: Counter;

// Running count of active agents who have committed at least once
export ledger active_agents: Counter;

// Total stake locked across all active commitments (in tNight units)
export ledger total_stake_locked: Counter;

// ============================================================================
// CIRCUITS (TRANSITION FUNCTIONS)
// ============================================================================
// Each circuit modifies public ledger state via zero-knowledge proofs.
// Private state (agent strategies, salts) remains hidden.

// commit_signal: An agent submits a hashed signal commitment with a stake.
// The hash is H(signal || salt) computed off-chain; only the commitment
// count and stake counter are updated on the public ledger.
//
// Mirrors: increment() in counter.compact, but updates multiple counters.
//
// On-chain effect:
//   total_commitments += 1
//   total_stake_locked += 1 (each commitment locks one fixed stake unit)
export circuit commit_signal(): [] {
  // Increment the global commitment counter (like round.increment(1) in counter)
  total_commitments.increment(1);

  // Track cumulative stake locked — one fixed unit per commitment.
  // Variable stake amounts are tracked off-chain to avoid witness disclosure.
  total_stake_locked.increment(1);
}

// reveal_signal: An agent reveals their original signal and salt, proving
// that their earlier commitment matches. The chain verifies the preimage.
//
// On-chain effect:
//   total_reveals += 1
//   total_stake_locked decremented by the original stake (via increment of a release counter)
export circuit reveal_signal(): [] {
  // Increment the global reveal counter
  total_reveals.increment(1);
}

// verify_signal: After market outcome is known, verify whether the revealed
// signal was correct. Updates the verified counter for scoring.
//
// On-chain effect:
//   total_verified += 1
export circuit verify_signal(): [] {
  total_verified.increment(1);
}

// register_agent: A new agent registers on the marketplace.
//
// On-chain effect:
//   active_agents += 1
export circuit register_agent(): [] {
  active_agents.increment(1);
}

// get_marketplace_stats: A read-only-like circuit that touches no state
// but can be used to trigger a proof that the caller has read access.
// In practice, ledger reads happen via the indexer; this circuit exists
// for completeness and potential future access-gated reads.
export circuit get_marketplace_stats(): [] {
  // No-op circuit — ledger state is read via the indexer public data provider.
  // This circuit exists to mirror the pattern where every user action is a circuit call.
  total_commitments.increment(0);
}
